# 一面

1.  面试官介绍面试流程
2. 自我介绍
3. 项目讨论（在过去两年的工作和实习中，任何一个项目任何一个技术点都可以，找一个你觉得是有一定技术挑战的一个点拿出聊一下吗，你需要描述一下他的难点在哪里，你的解决思路和解决方案是什么，最终取得了一个怎样的收益）
   1. 基于Redis+定时任务的卡池缓存
      1. 几十张卡量比较小，直接读数据库不能满足你们的要求吗？为什么一定要刷到内存里面的呢
      2. 服务启动的时候init函数的操作是把db里面的数据初始化到内存里面，后面就是更新和新增的卡怎么及时刷到内存里面，用redis的发布订阅。为什么不用go自带的channel功能来实现这个刷新而是用redis
      3. 为什么用redis 的发布订阅而不是监听一个binlog，增加和更新卡的时候，是不是监听binlog来更新更合理一些？你们公司有相关的技术中间件吗，通过监听binlog来刷到内存或redis
      4. mysql的binlog有了解吗
      5. 通过redis 的发布订阅来把数据的一些变更重新refresh到内存里面，现在有两个数据，一个内存的数据，一个db的数据。如果有两个数据需要考虑数据不一致的问题，比如发布订阅中间出现了异常，数据库更新了，但是内存没有刷新，两边的数据不一致你们是如何监控和解决的。（我的回答：定时任务，30分钟一次）
      6. 这个30分钟是怎么拍出来的，如果redis没监听成功，那这30分钟内都有可能数据不一致，这30分钟是能容忍的吗？
      7. 比如说现在抽了一个高级卡，现在需要把高级卡下掉，这步操作呢又没有refresh到内存里面。相当于30分钟之内用户还是能抽到高级卡，这段时间的数据容忍性怎么拍出来的？还是说业务能接受，有没有什么指标来衡量这个30分钟，20分钟，或者5分钟，这个意思。
      8. 用户抽卡和用户核销卡是隔离的还是耦合的？比如用户抽了一张卡a，还没有用，后续你们gm后台对这个a卡进行了编辑或者说下卡，那这个a还能用吗？
      9. 不能用，那用户肯定要投诉了
      10. 那该怎么实现这个下卡功能，老用户抽到卡下了还能继续用
      11. 团队几个人，包括toc和tob，你现在主要是toc还是tob？
4. 技术知识
   1. defer应用于哪些场景，解决哪些问题，常用它做什么
   2. defer他的一个实现的原理有看过吗，怎样的一个结构
   3. 多个defer他的执行时机和执行顺序是怎样的
   4. 场景：使用defer去recover panic的时候，有这么一个场景，比如说有一个协程a，在a中开辟了一个新的线程b，相当于a是b的一个父线程。这个时候在a的线程里面设置了一个defer去recover panic，b协程是没有recover panic 的。
      1. 有两种场景，第一种场景是当a协程在后续的执行过程中出现了空指针也就是触发了panic，这个时候我的这个进程会不会异常重启，这个panic能不能被捕获到？
         - **进程不会异常重启**：Go语言的panic/recover机制是在goroutine级别上工作的，而不是在进程级别。因此，当某个goroutine发生panic时，它默认会导致该goroutine的终止，但不会影响其他正在运行的goroutine或整个进程。
         - **panic可以被捕获到**：如果您在a协程中设置了defer函数并在其中调用了recover，那么当a协程中发生panic时，该panic会被recover捕获。recover会结束当前的panic序列，让goroutine恢复正常执行流程（从defer函数之后的语句开始）。
      2. 如果b协程没有recover panic，然后b协程触发了panic，b协程会退出，a协程不会退出是吗，还是说整个进程都会重启
         - **b协程会退出**：当b协程中发生panic且没有相应的recover来捕获它时，b协程会立即终止。
         - **a协程不会因b协程的panic而退出**：Go的goroutine是独立运行的，一个goroutine的panic不会影响到其他goroutine（除非有特殊的同步机制如通道（channel）等，但这些通常不会导致panic的传播）。因此，a协程会继续执行，不受b协程panic的影响。
         - **整个进程不会重启**：如前面所述，panic和recover是在goroutine级别上处理的，不会影响整个进程。只有当所有非守护（daemon）goroutine都结束时，程序（即进程）才会退出。守护goroutine是那些在main函数返回后仍然运行的goroutine，但通常情况下，我们不会故意创建这样的goroutine。
   5. map
      1. 是读写安全的吗
      2. 想并发的去读写一个map该怎么做呢
      3. sync.Map的底层实现有看过吗 
      4. map的数据结构有看过吗，怎么实现的一个原理
      5. map有一个has桶，会有hash冲突，go 的map是如何解决hash冲突的
      6. 溢出桶
      7. 扩容问题，什么情况下会扩容，扩容的机制是怎样的，有几种扩容方式
      8. 等量扩容跟溢出桶相关了，是什么情况下会触发
   6. mysql
      1. 两个概念，聚簇索引和非聚簇索引，这两个概念分表是代表什么样的含义，他们在数据的组织形式上有什么差异
         1. 使用非聚簇索引进行查询数据的时候一定会发生回表吗？什么情况下可以不回表
         2. 场景：有一个表，很多字段abcdefg，组成一个联合索引abc，查询语句是select * from table where a = ？；这个时候会不会发生回表，abc都是不主键。
         3. 这个查询语句会覆盖索引吗
            1. **如果查询只需要索引中的列**：如果查询只请求了索引中的列（在这个例子中是`a`, `b`, `c`），那么MySQL可以直接从索引中获取这些列的值，而不需要回表去获取完整的数据行。这种情况下，查询是高效的，因为它避免了额外的磁盘I/O。
            2. **如果查询需要非索引列**：在你的例子中，查询使用了`SELECT *`，这意味着MySQL需要检索表中的所有列。由于`d`, `e`, `f`, `g`等列不在索引`abc`中，因此MySQL必须执行回表操作，通过索引找到的`a`字段对应的行主键（或内部行ID），然后使用该主键去聚集索引中检索完整的行数据。
         4. 在您提到的查询语句 `SELECT * FROM table WHERE a = ?;` 中，该查询**不会**完全覆盖索引，尽管它利用了由字段 `a`, `b`, `c` 组成的联合索引 `abc` 的最左前缀 `a` 来快速定位行。
            1. **索引覆盖** 的定义是：如果查询的列完全包含在索引中，则称为索引覆盖。在这种情况下，MySQL 可以直接从索引中检索出所需的数据，而无需回表去访问表中的数据行。这通常可以提高查询性能，因为索引通常比表数据小得多，存储在磁盘上的位置也更紧凑，减少了磁盘I/O的需求。
            2. 然而，在您的查询中，使用了 `SELECT *` 来检索所有列，这包括了不在索引 `abc` 中的列（如 `d`, `e`, `f`, `g`）。因此，即使查询条件 `a = ?` 能够通过索引快速定位到满足条件的行，MySQL 也需要回表去获取那些不在索引中的列的数据。
            3. 为了使查询能够利用索引覆盖，您应该只选择索引中包含的列，例如：SELECT a, b, c FROM table WHERE a = ?;
            4. 这样的查询将能够完全通过索引来获取所需的数据，而无需回表，从而提高查询性能。如果您需要检索非索引列，并且这些查询非常频繁，那么您可能需要考虑对表结构或索引策略进行调整，以优化性能。
5. 算法
```
//1. 给出一个长度非空的整形数组，元素值先递增后递减，找出数组中的最大值
//eg: []int{1, 2, 3, 4, 6, 3, 1} 输出6
//eg: []int{1, 2, 3, 4, 6} 输出6
//eg: []int{6, 4, 3, 2, 1} 输出6
```

   1. 方法1：遍历，时间复杂度O(n)
   2. 方法2：双指针，logn
```go
// 初始化两个指针 left 和 right 分别指向数组的第一个元素和最后一个元素。
// 进入循环，直到 left 指针小于 right 指针：
// a. 计算中间指针 mid。
// b. 如果 mid 指向的元素大于其右侧的元素，说明最大值可能在 mid 或其左侧，因此将 right 指针移动到 mid。
// c. 否则，说明最大值可能在 mid 的右侧（但不在 mid 本身，因为数组是先递增后递减的），因此将 left 指针移动到 mid + 1。
// 当循环结束时，left 和 right 指针会相遇，它们指向的元素就是数组中的最大值。
// 这个算法的时间复杂度是 O(logn)，因为它每次都将搜索范围减半，直到找到最大值。
func findMaxValue(arr []int) int {
    left, right := 0, len(arr)-1
    for left < right {
        mid := left + (right-left)/2

        // 如果 mid 指向的元素 > 右侧的，说明 max 在 mid 或其左侧
        if arr[mid] > arr[mid+1] {
            right = mid
        } else {
            // max 在 mid 右侧
            left = mid + 1
        }
    }
    // left == right 此时 max
    return arr[left]
}

func main() {

    fmt.Println(findMaxValue([]int{1, 2, 3, 4, 6, 3, 1}))
    fmt.Println(findMaxValue([]int{1, 2, 3, 4, 6, 7}))
    fmt.Println(findMaxValue([]int{7, 6, 4, 3, 2, 1}))
}
```

6. 反向QA 
   1. 滴滴新成立的一个部门，机票火车票旅游酒店租车主要这么几个业务线，我们组是负责租车的
   2. 技术栈，go语言，mysql，redis，kafka，MQ等
   3. 不用紧张，刚毕业一年，感觉是一个比较有激情的一个同学，总体感觉还行，负责的内容也挺多，tob和toc都有涉及，自己负责的也比较多，比较能干的，负责的东西很多，也要注意一下沉淀。第一个问题的比较有技术难点和挑战点的这些东西都要沉淀下来，其他的都还行。
